/* 
* BSD 3-Clause License
* 
* Copyright (c) 2025, Marco Menegazzi
* 
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
* 
* 1. Redistributions of source code must retain the above copyright notice, this
*   list of conditions and the following disclaimer.
*
* 2. Redistributions in binary form must reproduce the above copyright notice,
*  this list of conditions and the following disclaimer in the documentation
*  and/or other materials provided with the distribution.
*
* 3. Neither the name of the copyright holder nor the names of its
*  contributors may be used to endorse or promote products derived from
*  this software without specific prior written permission.
* 
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
* FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

import 'dart:io';

import 'config.dart';
import 'enviroment.dart';
import 'models/tessera.dart';
import 'models/profile.dart';
import 'exception.dart';
import 'utils/gesso.dart';
import 'utils/utils.dart';

class Context {
  Context({required this.config, required this.env});
  final Configuration config;
  final Environment env;

  static String banner(List<String> lines) =>
      '''
// **************************************************
// Generated by Mosaic CLI
// https://github.com/marcomit/mosaic
// Timestamp: ${DateTime.now()}
//
${lines.map((l) => '// $l').join('\n')}
// **************************************************
''';

  Future<Set<Tessera>> tesserae([String? root]) async {
    final result = <Tessera>{};
    final paths = await env.getExistingTesserae(root);

    for (final path in paths) {
      final tessera = await getTesseraFromPath(path);
      if (tessera != null) result.add(tessera);
    }

    return result;
  }

  Future<Tessera?> getTesseraFromPath(String path) async {
    final content = await config.read(
      utils.join([path, Environment.tesseraMark]),
    );
    return Tessera.fromJson(content, path);
  }

  Future<Tessera?> getTesseraFromName(String name) async {
    final paths = await env.getExistingTesserae();

    for (final path in paths) {
      if (utils.split(path).last == name) {
        return getTesseraFromPath(path);
      }
    }
    return null;
  }

  Future<void> checkEnvironment() async {
    final isValid = await env.isValid();
    if (!isValid) {
      throw CliException('You are not inside a valid mosaic project'.red);
    }
    await config.loadFromEnv();
  }

  Future<String> getInitializationFile(
    List<Tessera> tesserae,
    String defaultTessera,
  ) async {
    final sorted = Tessera.topologicalSort(tesserae);
    final buf = StringBuffer();
    buf.writeln(
      banner([
        'Tesserae were loaded in TOPOLOGICAL ORDER.',
        'Circular dependencies are detected automatically',
        'If a circular dependency exists, your app might CRASH.',
        'Please keep your tesserae organized ',
        'and don\'t turn your app into garbage!',
      ]),
    );
    buf.writeln('import \'package:mosaic/mosaic.dart\';');
    for (final tessera in sorted) {
      buf.writeln(
        'import \'package:${tessera.name}/${tessera.name}.dart\' as ${tessera.name};',
      );
    }

    buf.writeln();
    buf.writeln('Future<void> init([List<Module> extras = const []]) async {');

    for (final tessera in sorted) {
      buf.writeln(tessera.generateInitialization());
    }

    buf.writeln('  await mosaic.registry.initialize($defaultTessera.module, [');

    sorted.where((t) => t.active).forEach((t) {
      buf.writeln('    ${t.name}.module,');
    });
    buf.writeln('    ...extras');

    buf.writeln('  ]);');

    buf.writeln('}');

    return buf.toString();
  }

  Future<void> writeInitializationFile(
    List<Tessera> tesserae,
    String defaultTessera,
  ) async {
    final content = await getInitializationFile(tesserae, defaultTessera);

    final name = config.get('name');
    final root = await env.root();

    final path = utils.join([root!.path, name, 'lib', 'init.dart']);

    final file = await utils.ensureExists(path);

    await file.writeAsString(content);
  }

  Future<Directory> main() async {
    final root = await env.root();

    if (root == null) throw const CliException('Not in a valid mosaic.');

    final name = config.get('name')!;

    return Directory(utils.join([root.path, name]));
  }

  Future<void> saveProfile(Profile profile) async {
    final profiles = config.get('profiles');

    profiles[profile.name] = profile.encode();

    await config.save();
  }
}
